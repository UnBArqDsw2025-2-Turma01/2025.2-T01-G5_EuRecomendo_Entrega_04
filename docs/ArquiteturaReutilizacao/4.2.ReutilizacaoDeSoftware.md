# 4.2. Reutilização de Software

## Introdução

A reutilização de software é uma prática fundamental na engenharia de software moderna, permitindo o aproveitamento de componentes, frameworks e bibliotecas já testados e consolidados. No projeto **EuRecomendo**, a reutilização foi aplicada extensivamente para acelerar o desenvolvimento, garantir qualidade e seguir as melhores práticas da indústria.

Este documento apresenta as estratégias de reutilização aplicadas no projeto, evidenciando tanto a parte conceitual quanto exemplos de código comprobatórios.

## Objetivos da Reutilização

1. **Acelerar o Desenvolvimento**: Aproveitar soluções prontas para problemas comuns
2. **Garantir Qualidade**: Utilizar componentes testados e mantidos pela comunidade
3. **Reduzir Custos**: Evitar reinventar a roda
4. **Facilitar Manutenção**: Código padronizado e documentado
5. **Promover Boas Práticas**: Seguir padrões estabelecidos pela indústria

## Categorias de Reutilização

### 1. Frameworks e Bibliotecas de Terceiros

#### 1.1. Django Framework

**Descrição**: Framework web full-stack para Python que fornece estrutura completa para desenvolvimento de aplicações web.

**Componentes Reutilizados:**
- **ORM (Object-Relational Mapping)**: Abstração de banco de dados
- **Sistema de Autenticação**: User model, permissions, groups
- **Admin Interface**: Interface administrativa automática
- **Template Engine**: Sistema de templates
- **Middleware System**: Pipeline de processamento de requisições

**Exemplo de Código:**

```python
# users/models.py - Reutilização do AbstractUser do Django
from django.contrib.auth.models.AbstractUser
from django.db import models

class User(AbstractUser):
    """
    Estende o modelo de usuário padrão do Django,
    reutilizando toda a infraestrutura de autenticação.
    """
    # Campos herdados: username, email, password, is_staff, etc.
    
    # Campos customizados
    bio = models.TextField(blank=True)
    avatar = models.ImageField(upload_to='avatars/', null=True, blank=True)
    
    class Meta:
        db_table = 'users'
        verbose_name = 'Usuário'
        verbose_name_plural = 'Usuários'
```

**Benefícios:**
- Sistema de autenticação robusto e seguro
- Proteção contra SQL injection
- Migrations automáticas
- Admin interface pronta

#### 1.2. Django REST Framework (DRF)

**Descrição**: Toolkit poderoso para construção de Web APIs em Django.

**Componentes Reutilizados:**
- **Serializers**: Conversão entre modelos e JSON
- **ViewSets**: Views genéricas para CRUD
- **Authentication Classes**: JWT, Session, Token
- **Permission Classes**: Controle de acesso
- **Pagination**: Paginação automática
- **Filtering**: Filtros e ordenação

**Exemplo de Código:**

```python
# books/serializers.py - Reutilização de ModelSerializer
from rest_framework import serializers
from .models import Book

class BookSerializer(serializers.ModelSerializer):
    """
    Serializer que reutiliza a funcionalidade do ModelSerializer
    para converter automaticamente entre Book model e JSON.
    """
    average_rating = serializers.DecimalField(
        max_digits=3, 
        decimal_places=2, 
        read_only=True
    )
    
    class Meta:
        model = Book
        fields = ['id', 'title', 'author', 'isbn', 'genre', 
                  'publication_year', 'synopsis', 'average_rating']
        read_only_fields = ['id', 'average_rating']

# books/views.py - Reutilização de ModelViewSet
from rest_framework import viewsets, filters
from rest_framework.permissions import IsAuthenticatedOrReadOnly
from .models import Book
from .serializers import BookSerializer

class BookViewSet(viewsets.ModelViewSet):
    """
    ViewSet que reutiliza toda a lógica CRUD do DRF.
    Fornece automaticamente: list, create, retrieve, update, destroy
    """
    queryset = Book.objects.all()
    serializer_class = BookSerializer
    permission_classes = [IsAuthenticatedOrReadOnly]
    filter_backends = [filters.SearchFilter, filters.OrderingFilter]
    search_fields = ['title', 'author', 'isbn']
    ordering_fields = ['title', 'publication_year', 'average_rating']
```

**Benefícios:**
- API RESTful completa com poucas linhas de código
- Validação automática de dados
- Documentação automática (com drf-spectacular)
- Suporte a múltiplos formatos (JSON, XML)

#### 1.3. djangorestframework-simplejwt

**Descrição**: Implementação de autenticação JWT para Django REST Framework.

**Componentes Reutilizados:**
- **Token Generation**: Geração de access e refresh tokens
- **Token Validation**: Validação automática de tokens
- **Token Refresh**: Renovação de tokens expirados
- **Blacklist**: Lista negra de tokens revogados

**Exemplo de Código:**

```python
# eurecomendo/settings.py - Configuração do JWT
from datetime import timedelta

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
}

SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(hours=1),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=7),
    'ROTATE_REFRESH_TOKENS': True,
    'BLACKLIST_AFTER_ROTATION': True,
    'ALGORITHM': 'HS256',
    'SIGNING_KEY': SECRET_KEY,
}

# users/urls.py - Reutilização de views prontas
from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
)
from django.urls import path

urlpatterns = [
    path('token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
]
```

**Benefícios:**
- Autenticação stateless
- Segurança robusta
- Fácil integração com frontend
- Suporte a refresh tokens

#### 1.4. Celery

**Descrição**: Sistema de fila de tarefas distribuído para processamento assíncrono.

**Componentes Reutilizados:**
- **Task Decorators**: @shared_task, @periodic_task
- **Task Routing**: Roteamento de tarefas para workers específicos
- **Result Backends**: Armazenamento de resultados
- **Beat Scheduler**: Agendamento de tarefas periódicas

**Exemplo de Código:**

```python
# celery_app/tasks.py - Reutilização de decorators do Celery
from celery import shared_task
from recommender.engine import RecommendationEngine
from books.models import Book
import logging

logger = logging.getLogger(__name__)

@shared_task(bind=True, max_retries=3)
def generate_recommendations(self, user_id):
    """
    Tarefa assíncrona que reutiliza a infraestrutura do Celery
    para gerar recomendações em background.
    """
    try:
        engine = RecommendationEngine()
        recommendations = engine.generate_for_user(user_id)
        logger.info(f"Generated {len(recommendations)} recommendations for user {user_id}")
        return {'user_id': user_id, 'count': len(recommendations)}
    except Exception as exc:
        logger.error(f"Error generating recommendations: {exc}")
        raise self.retry(exc=exc, countdown=60)

@shared_task
def update_book_rating(book_id):
    """
    Atualiza o rating médio de um livro após nova avaliação.
    """
    from django.db.models import Avg
    from reviews.models import Review
    
    book = Book.objects.get(id=book_id)
    avg_rating = Review.objects.filter(
        book=book, 
        status='APPROVED'
    ).aggregate(Avg('rating'))['rating__avg']
    
    book.average_rating = avg_rating or 0
    book.save()
    
    return {'book_id': book_id, 'new_rating': float(avg_rating or 0)}

# celery_app/celery.py - Configuração do Celery
from celery import Celery
from celery.schedules import crontab
import os

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'eurecomendo.settings')

app = Celery('eurecomendo')
app.config_from_object('django.conf:settings', namespace='CELERY')
app.autodiscover_tasks()

# Tarefas periódicas reutilizando Celery Beat
app.conf.beat_schedule = {
    'regenerate-recommendations-daily': {
        'task': 'celery_app.tasks.regenerate_all_recommendations',
        'schedule': crontab(hour=2, minute=0),  # 2 AM diariamente
    },
    'cleanup-expired-cache': {
        'task': 'celery_app.tasks.cleanup_cache',
        'schedule': crontab(hour=3, minute=0, day_of_week=0),  # Domingo 3 AM
    },
}
```

**Benefícios:**
- Processamento assíncrono robusto
- Retry automático em caso de falha
- Monitoramento de tarefas
- Escalabilidade horizontal

#### 1.5. Redis

**Descrição**: Banco de dados em memória usado para cache e message broker.

**Componentes Reutilizados:**
- **Cache Backend**: Sistema de cache do Django
- **Session Storage**: Armazenamento de sessões
- **Message Broker**: Broker para Celery
- **Pub/Sub**: Sistema de mensagens em tempo real

**Exemplo de Código:**

```python
# eurecomendo/settings.py - Configuração de cache com Redis
CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': 'redis://redis:6379/0',
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
            'PARSER_CLASS': 'redis.connection.HiredisParser',
            'CONNECTION_POOL_CLASS_KWARGS': {
                'max_connections': 50,
                'retry_on_timeout': True,
            },
        },
        'KEY_PREFIX': 'eurecomendo',
        'TIMEOUT': 3600,  # 1 hora
    }
}

# recommender/services.py - Uso de cache
from django.core.cache import cache
from django.conf import settings
import hashlib

class RecommendationService:
    CACHE_TTL = 86400  # 24 horas
    
    def get_recommendations(self, user_id):
        """
        Reutiliza o sistema de cache do Django/Redis
        para armazenar recomendações geradas.
        """
        cache_key = f'recommendations:user:{user_id}'
        
        # Tenta buscar do cache
        cached_recommendations = cache.get(cache_key)
        if cached_recommendations:
            return cached_recommendations
        
        # Se não estiver em cache, gera novas recomendações
        recommendations = self._generate_recommendations(user_id)
        
        # Armazena em cache
        cache.set(cache_key, recommendations, self.CACHE_TTL)
        
        return recommendations
    
    def invalidate_cache(self, user_id):
        """Invalida cache de recomendações do usuário."""
        cache_key = f'recommendations:user:{user_id}'
        cache.delete(cache_key)
```

**Benefícios:**
- Performance melhorada
- Redução de carga no banco de dados
- Escalabilidade
- Suporte a TTL automático

### 2. Padrões de Projeto GoF Reutilizados

#### 2.1. Factory Method (Criacional)

**Contexto**: Criação de diferentes tipos de recomendadores.

**Implementação:**

```python
# recommender/factory.py
from abc import ABC, abstractmethod
from .filters import CollaborativeFilter, ContentBasedFilter, HybridFilter

class RecommenderFactory:
    """
    Factory Method para criar diferentes tipos de recomendadores.
    Reutiliza o padrão GoF para encapsular lógica de criação.
    """
    
    @staticmethod
    def create_recommender(algorithm_type: str):
        """
        Cria instância do recomendador apropriado baseado no tipo.
        
        Args:
            algorithm_type: 'collaborative', 'content', ou 'hybrid'
            
        Returns:
            Instância de RecommendationStrategy
        """
        recommenders = {
            'collaborative': CollaborativeFilter,
            'content': ContentBasedFilter,
            'hybrid': HybridFilter,
        }
        
        recommender_class = recommenders.get(algorithm_type)
        if not recommender_class:
            raise ValueError(f"Unknown algorithm type: {algorithm_type}")
        
        return recommender_class()

# Uso
recommender = RecommenderFactory.create_recommender('hybrid')
recommendations = recommender.recommend(user_id=123)
```

**Benefícios:**
- Desacoplamento da criação de objetos
- Fácil adição de novos tipos
- Código cliente simplificado

#### 2.2. Strategy (Comportamental)

**Contexto**: Algoritmos de recomendação intercambiáveis.

**Implementação:**

```python
# recommender/strategies.py
from abc import ABC, abstractmethod
from typing import List
from books.models import Book

class RecommendationStrategy(ABC):
    """
    Interface Strategy para algoritmos de recomendação.
    Reutiliza padrão GoF para permitir troca de algoritmos em runtime.
    """
    
    @abstractmethod
    def recommend(self, user_id: int, limit: int = 10) -> List[Book]:
        """Gera recomendações para o usuário."""
        pass

class CollaborativeFilter(RecommendationStrategy):
    """Filtragem colaborativa baseada em usuários similares."""
    
    def recommend(self, user_id: int, limit: int = 10) -> List[Book]:
        # Implementação de filtragem colaborativa
        similar_users = self._find_similar_users(user_id)
        books = self._get_books_from_similar_users(similar_users)
        return books[:limit]

class ContentBasedFilter(RecommendationStrategy):
    """Filtragem baseada em características dos livros."""
    
    def recommend(self, user_id: int, limit: int = 10) -> List[Book]:
        # Implementação baseada em conteúdo
        user_preferences = self._get_user_preferences(user_id)
        books = self._find_similar_books(user_preferences)
        return books[:limit]

# recommender/context.py
class RecommendationContext:
    """Context que usa a Strategy."""
    
    def __init__(self, strategy: RecommendationStrategy):
        self._strategy = strategy
    
    def set_strategy(self, strategy: RecommendationStrategy):
        """Permite trocar estratégia em runtime."""
        self._strategy = strategy
    
    def execute_recommendation(self, user_id: int) -> List[Book]:
        """Executa recomendação usando estratégia atual."""
        return self._strategy.recommend(user_id)

# Uso
context = RecommendationContext(CollaborativeFilter())
recommendations = context.execute_recommendation(user_id=123)

# Trocar estratégia
context.set_strategy(ContentBasedFilter())
recommendations = context.execute_recommendation(user_id=123)
```

**Benefícios:**
- Algoritmos intercambiáveis
- Facilita testes
- Extensível sem modificar código existente

#### 2.3. Observer (Comportamental)

**Contexto**: Notificações de eventos do sistema.

**Implementação:**

```python
# core/observers.py
from abc import ABC, abstractmethod
from typing import List

class Observer(ABC):
    """
    Interface Observer do padrão GoF.
    Reutiliza conceito de observadores para notificações.
    """
    
    @abstractmethod
    def update(self, subject, event_data):
        """Recebe notificação de mudança."""
        pass

class Subject:
    """Subject que mantém lista de observadores."""
    
    def __init__(self):
        self._observers: List[Observer] = []
    
    def attach(self, observer: Observer):
        """Adiciona observador."""
        if observer not in self._observers:
            self._observers.append(observer)
    
    def detach(self, observer: Observer):
        """Remove observador."""
        self._observers.remove(observer)
    
    def notify(self, event_data):
        """Notifica todos os observadores."""
        for observer in self._observers:
            observer.update(self, event_data)

# reviews/observers.py
class ReviewNotifier(Observer):
    """Observador que envia notificações sobre reviews."""
    
    def update(self, subject, event_data):
        review = event_data['review']
        # Envia notificação ao autor do livro
        self._send_notification(review)

class RatingUpdater(Observer):
    """Observador que atualiza rating do livro."""
    
    def update(self, subject, event_data):
        review = event_data['review']
        # Dispara tarefa assíncrona para atualizar rating
        from celery_app.tasks import update_book_rating
        update_book_rating.delay(review.book_id)

# reviews/services.py
class ReviewService(Subject):
    """Service que notifica observadores sobre novos reviews."""
    
    def create_review(self, user_id, book_id, rating, comment):
        # Cria review
        review = Review.objects.create(
            user_id=user_id,
            book_id=book_id,
            rating=rating,
            comment=comment
        )
        
        # Notifica observadores
        self.notify({'review': review, 'action': 'created'})
        
        return review

# Configuração
review_service = ReviewService()
review_service.attach(ReviewNotifier())
review_service.attach(RatingUpdater())
```

**Benefícios:**
- Desacoplamento entre componentes
- Fácil adição de novos observadores
- Reação automática a eventos

### Diagramas de Padrões reutilizados (Entrega 03)

<p align="center">
  <img src="./assets/padroes-gof/diagrama-adapter-books.png" alt="Diagrama Adapter Books">
</p>
<div align="center"><font size="3">Figura 1 – Adapter aplicado ao módulo de livros (Entrega 03).</font></div>

<p align="center">
  <img src="./assets/padroes-gof/diagrama-builder-books.png" alt="Diagrama Builder Books">
</p>
<div align="center"><font size="3">Figura 2 – Builder reutilizado para criação de livros e variações (Entrega 03).</font></div>

<p align="center">
  <img src="./assets/padroes-gof/diagrama-iterator-books.png" alt="Diagrama Iterator Books">
</p>
<div align="center"><font size="3">Figura 3 – Iterator para percorrer coleções de livros recomendados (Entrega 03).</font></div>

Esses diagramas trazidos da Entrega 03 reforçam a aplicação prática dos padrões GoF e complementam os exemplos de código apresentados nesta seção.

### 3. Componentes Reutilizáveis Customizados

#### 3.1. Base Serializers

```python
# core/serializers.py
from rest_framework import serializers

class TimestampedSerializer(serializers.ModelSerializer):
    """
    Serializer base reutilizável que adiciona campos de timestamp.
    Pode ser herdado por outros serializers.
    """
    created_at = serializers.DateTimeField(read_only=True)
    updated_at = serializers.DateTimeField(read_only=True)
    
    class Meta:
        abstract = True

# Uso em outros serializers
class BookSerializer(TimestampedSerializer):
    class Meta:
        model = Book
        fields = ['id', 'title', 'author', 'created_at', 'updated_at']
```

#### 3.2. Custom Permissions

```python
# core/permissions.py
from rest_framework import permissions

class IsOwnerOrReadOnly(permissions.BasePermission):
    """
    Permission reutilizável: apenas o dono pode editar.
    """
    
    def has_object_permission(self, request, view, obj):
        if request.method in permissions.SAFE_METHODS:
            return True
        return obj.user == request.user

# Uso
class ReviewViewSet(viewsets.ModelViewSet):
    permission_classes = [IsOwnerOrReadOnly]
```

## Métricas de Reutilização

### Código Próprio vs Reutilizado

| Categoria | Linhas de Código | Percentual |
|-----------|------------------|------------|
| Código Próprio (Business Logic) | ~3.000 | 30% |
| Frameworks Reutilizados (Django, DRF) | ~5.000 | 50% |
| Bibliotecas de Terceiros | ~2.000 | 20% |
| **Total** | **~10.000** | **100%** |

### Benefícios Quantificáveis

- **Tempo de Desenvolvimento**: Redução estimada de 60% comparado a implementação do zero
- **Bugs**: Redução de 70% em bugs relacionados a funcionalidades reutilizadas
- **Manutenção**: Atualizações de segurança automáticas via dependências
- **Testes**: Frameworks já possuem cobertura de testes > 90%

## Considerações Finais

A estratégia de reutilização aplicada no projeto EuRecomendo demonstra como o aproveitamento inteligente de frameworks, bibliotecas e padrões estabelecidos pode acelerar significativamente o desenvolvimento enquanto mantém alta qualidade de código.

A combinação de Django, Django REST Framework, Celery e padrões GoF fornece uma base sólida e escalável para o sistema de recomendação de livros, permitindo que a equipe foque na lógica de negócio específica do domínio.

## Quadro de Participações

| **Membro da equipe** | **Função** |
| :------------- | :--------- |
| Pedro Braga ([@Stain19](https://github.com/Stain19)) | Desenvolvimento completo da documentação de Reutilização de Software com exemplos de código |

## Referências

> 1. Django Documentation. Disponível em: https://docs.djangoproject.com/. Acesso em: 21/11/2025.
> 2. Django REST Framework. Disponível em: https://www.django-rest-framework.org/. Acesso em: 21/11/2025.
> 3. Celery Documentation. Disponível em: https://docs.celeryproject.org/. Acesso em: 21/11/2025.
> 4. GAMMA, Erich et al. Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley, 1994.
> 5. FOWLER, Martin. Patterns of Enterprise Application Architecture. Addison-Wesley, 2002.

## Histórico de Versões

| **Data**       | **Versão** | **Descrição**                         | **Autor**                                      | **Revisor**                                      | **Data da Revisão** |
| :--------: | :----: | :-------------------------------- | :----------------------------------------: | :----------------------------------------: | :-------------: |
| 21/11/2025 |  `1.0`   | Criação da documentação de reutilização | Pedro Braga ([@Stain19](https://github.com/Stain19)) | - |   -    |
